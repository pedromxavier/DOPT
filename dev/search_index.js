var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Solution-Methods","page":"API","title":"Solution Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DOPT.MetaHeuristic\nDOPT.AntColony\nDOPT.SimulatedAnnealing\nDOPT.LocalSearch\nDOPT.IteratedLocalSearch\nDOPT.PathRelinking","category":"page"},{"location":"api/#DOPT.MetaHeuristic","page":"API","title":"DOPT.MetaHeuristic","text":"MetaHeuristic\n\nThe abstract class for defining new solution methods, to be used for triggering multiple dispatch over solve and init\n\n\n\n\n\n","category":"type"},{"location":"api/#DOPT.SimulatedAnnealing","page":"API","title":"DOPT.SimulatedAnnealing","text":"Simulated Annealing\n\n\n\n\n\n","category":"type"},{"location":"api/#DOPT.IteratedLocalSearch","page":"API","title":"DOPT.IteratedLocalSearch","text":"Iterated Local Search\n\n\n\n\n\n","category":"type"},{"location":"api/#DOPT.PathRelinking","page":"API","title":"DOPT.PathRelinking","text":"PathRelinking{M<:RelinkingMode} <: MetaHeuristic\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DOPT.init\nDOPT.solve","category":"page"},{"location":"api/#DOPT.init","page":"API","title":"DOPT.init","text":"init(A::Matrix{T})\ninit(A::Matrix{T}, R::Matrix{T})\ninit(::MetaHeuristic, A::Matrix{T})\ninit(::MetaHeuristic, A::Matrix{T}, R::Matrix{T})\n\n\n\n\n\n","category":"function"},{"location":"api/#DOPT.solve","page":"API","title":"DOPT.solve","text":"solve(::MetaHeuristic, A::Matrix{T}, s::Integer, args...; params...) where {T}\nsolve(::MetaHeuristic, A::Matrix{T}, R::Vector{Int}, s::Integer, args...; params...) where {T}\n\nSolves the Determinant-Optimality problem for a given matrix A in mathbbR^m times n.\n\n\n\n\n\n","category":"function"},{"location":"api/#Metrics","page":"API","title":"Metrics","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DOPT.gap","category":"page"},{"location":"api/#DOPT.gap","page":"API","title":"DOPT.gap","text":"gap(z::T, zÌ„::T)\n\nComputes the relative gap between a solution z and the reference value barz.\n\nRationale\n\nLet\n\nbeginalign*\n    z       = logdet A cdot diagm(x) cdot A \n    barz = logdet A cdot diagm(barx) cdot A\nendalign*\n\nThen, is is possible to compute the relative gap as\n\nbeginalign*\n    z - barz     = logdet A cdot diagm(x) cdot A - logdet A cdot diagm(barx) cdot A \n                    = logfracdet A cdot diagm(x) cdot Adet A cdot diagm(barx) cdot A 2ex\n1 - e^z - barz = fracdet A cdot diagm(barx) cdot A - det A cdot diagm(x) cdot Adet A cdot diagm(barx) cdot A \n    \nendalign*\n\ninfo: Info\nIt is assumed that det A cdot diagm(barx) cdot A ge 0. This computation comes from calling logabsdet.\n\n\n\n\n\n","category":"function"},{"location":"api/#Instances-and-Results","page":"API","title":"Instances & Results","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DOPT.read_instance\nDOPT.read_solution\nDOPT.update_solution!","category":"page"},{"location":"api/#DOPT.read_instance","page":"API","title":"DOPT.read_instance","text":"read_instance(n::Integer, i::Integer)\nread_instance(n::Integer, i::Integer, matrix_name::Symbol)\n\nExample\n\njulia> A, R = read_instance(200, 2);\n\nor\n\njulia> A = read_instance(200, 2, :A);\n\njulia> R = read_instance(200, 2, :R);\n\n\n\n\n\n","category":"function"},{"location":"api/#DOPT.read_solution","page":"API","title":"DOPT.read_solution","text":"read_solution(n::Integer, i::Integer)\n\n\n\n\n\n","category":"function"},{"location":"#DOPT-Determinant-Optimality","page":"Home","title":"DOPT - Determinant Optimality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The binary D-OPT problem for a given matrix A in mathbbR^m times n and a positive integer s le m is stated as:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginarrayrl\n       max  logdet A cdot textdiagm(mathbfx) cdot A \ntextst  sum_i mathbfx_i = s \n             mathbfx in mathbbB^m\nendarray","category":"page"},{"location":"#Some-insights","page":"Home","title":"Some insights","text":"","category":"section"},{"location":"#Neighborhood","page":"Home","title":"Neighborhood","text":"","category":"section"},{"location":"#Objective-value","page":"Home","title":"Objective value","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"One could write f(mathbfx) = logdet A cdot textdiagm(mathbfx) cdot A as","category":"page"},{"location":"","page":"Home","title":"Home","text":"logdet sum_i = 1^m mathbfx_i mathbfa_i mathbfa_i","category":"page"},{"location":"","page":"Home","title":"Home","text":"where mathbfa_i is the i-th row of A. This allows one to pre-compute the \"objective matrix\" X = sum_i = 1^m mathbfx_i mathbfa_i mathbfa_i to speed up the evaluation of the objective function after walking to a neighbor state.","category":"page"}]
}
